##############################################################################
# Copyright (c) 2017-2019, Lawrence Livermore National Security, LLC.
# Produced at the Lawrence Livermore National Laboratory.
#
# This file is part of Hatchet.
# Created by Abhinav Bhatele <bhatele@llnl.gov>.
# LLNL-CODE-741008. All rights reserved.
#
# For details, see: https://github.com/LLNL/hatchet
# Please also read the LICENSE file for the MIT License notice.
##############################################################################
import pandas as pd

from .hpctoolkit_reader import HPCToolkitReader
from .caliper_reader import CaliperReader
from .gprof_dot_reader import GprofDotReader
from .node import Node
from .graph import Graph


class GraphFrame:
    """ An input dataset is read into an object of this type, which includes a
        graph and a dataframe.
    """

    def __init__(self, graph=None, dataframe=pd.DataFrame()):
        self.graph = graph
        self.dataframe = dataframe

    def from_hpctoolkit(self, dirname):
        """ Read in an HPCToolkit database directory.
        """
        reader = HPCToolkitReader(dirname)

        (self.graph, self.dataframe, self.exc_metrics,
            self.inc_metrics) = reader.create_graphframe()

    def from_caliper(self, filename):
        """ Read in a Caliper Json-split file.
        """
        reader = CaliperReader(filename)

        (self.graph, self.dataframe, self.exc_metrics,
            self.inc_metrics) = reader.create_graphframe()

    def from_gprof_dot(self, filename):
        """ Read in a DOT file generated by gprof2dot.
        """
        reader = GprofDotReader(filename)

        (self.graph, self.dataframe, self.exc_metrics,
            self.inc_metrics) = reader.create_graphframe()

    def from_literal(self, graph_dict):
        """ Read graph from a dict literal.
        """
        def parse_node_literal(child_dict, hparent, parent_callpath):
            """ Create node_dict for one node and then call the function
                recursively on all children.
            """
            node_callpath = parent_callpath
            node_callpath.append(child_dict['name'])
            hnode = Node(tuple(node_callpath), hparent)

            node_dicts.append(dict({'node': hnode, 'name': child_dict['name']}, **child_dict['metrics']))
            hparent.add_child(hnode)

            if 'children' in child_dict:
                for child in child_dict['children']:
                    parse_node_literal(child, hnode, list(node_callpath))

        # start with creating a node_dict for the root
        root_callpath = []
        root_callpath.append(graph_dict['name'])
        graph_root = Node(tuple(root_callpath), None)

        node_dicts = []
        node_dicts.append(dict({'node': graph_root, 'name': graph_dict['name']}, **graph_dict['metrics']))

        # call recursively on all children of root
        if 'children' in graph_dict:
            for child in graph_dict['children']:
                parse_node_literal(child, graph_root, list(root_callpath))

        self.exc_metrics = []
        self.inc_metrics = []
        for key in graph_dict['metrics'].keys():
            if '(inc)' in key:
                self.inc_metrics.append(key)
            else:
                self.exc_metrics.append(key)

        self.graph = Graph([graph_root])
        self.dataframe = pd.DataFrame(data=node_dicts)
        self.dataframe.set_index(['node'], drop=False, inplace=True)

    def filter(self, filter_function):
        """ Filter the dataframe using a user supplied function.
        """
        filtered_rows = self.dataframe.apply(filter_function, axis=1)
        filtered_df = self.dataframe[filtered_rows]

        filtered_gf = GraphFrame()
        filtered_gf.dataframe = filtered_df
        filtered_gf.graph = self.graph
        return filtered_gf

    def graft(self):
        """ Graft the graph after a filtering operation on the graphframe.
        """
        num_nodes = len(self.graph)

        # calculate number of unique nodes in the dataframe
        if 'rank' in self.dataframe.columns:
            num_rows_df = len(self.dataframe.groupby(['rank']))
        else:
            num_rows_df = len(self.dataframe.index)

        # the dataframe should already have a filtered set of nodes
        filtered_nodes = self.dataframe.index
        node_clone = {}
        new_roots = []

        # function to connect a node to the nearest descendants that are in the
        # list of filtered nodes
        def rewire_tree(node, clone, is_root):
            cur_children = node.children
            new_children = []

            # iteratively go over the children of a node
            while(cur_children):
                for child in cur_children:
                    cur_children.remove(child)
                    if child in filtered_nodes:
                        new_children.append(child)
                    else:
                        for grandchild in child.children:
                            cur_children.append(grandchild)

            if node in filtered_nodes:
                # create new clones for each child in new_children and rewire
                # with this node
                for new_child in new_children:
                    new_child_callpath = list(clone.callpath)
                    new_child_callpath.append(new_child.callpath[-1])
                    new_child_clone = Node(tuple(new_child_callpath), clone)
                    node_clone[new_child] = new_child_clone
                    clone.add_child(new_child_clone)
                    rewire_tree(new_child, new_child_clone, False)
            elif is_root:
                # if we reach here, this root is not in the graph anymore
                # make all its nearest descendants roots in the new graph
                for new_child in new_children:
                    new_child_clone = Node(tuple([new_child.callpath[-1]]), None)
                    node_clone[new_child] = new_child_clone
                    new_roots.append(new_child_clone)
                    rewire_tree(new_child, new_child_clone, False)

        # only do a graft if a filtering operation has been applied
        if num_nodes != num_rows_df:
            for root in self.graph.roots:
                if root in filtered_nodes:
                    clone = Node(tuple(root.callpath[-1],), None)
                    new_roots.append(clone)
                    node_clone[node] = clone
                    rewire_tree(root, clone, True)
                else:
                    rewire_tree(root, None, True)

        for root in new_roots:
            print '1',
            print root.callpath
            for child in root.children:
                print '\t2',
                print child.callpath

        new_dataframe = self.dataframe.copy()
        new_dataframe['node'] = new_dataframe['node'].apply(lambda x: node_clone[x])
        new_dataframe.set_index(['node'], drop=False, inplace=True)
        print new_dataframe

        new_graphframe = GraphFrame()
        new_graphframe.dataframe = new_dataframe
        new_graphframe.graph = Graph(new_roots)

        return new_graphframe

    def __isub__(self, other):
        for metric in self.exc_metrics + self.inc_metrics:
            self.dataframe[metric] = self.dataframe[metric].subtract(other.dataframe[metric])
        return GraphFrame(self.graph, self.dataframe)

    def __sub__(self, other):
        """ Compute the scalar difference of two data frames with identical
            graphs
        """
        res_gf = self.__isub__(other)
        return GraphFrame(res_gf.graph, res_gf.dataframe)
